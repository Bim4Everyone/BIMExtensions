# -*- coding: utf-8 -*-
# -*- coding: utf-8 -*-
import os.path as op
import os
import sys
import clr
import math
import collections
from shutil import copyfile
from pyrevit import forms
from pyrevit import revit

from pyrevit.framework import Controls
clr.AddReference('System')
clr.AddReference('System.IO')
clr.AddReference("System.Windows.Forms") 
#clr.AddReference("System.Windows.Controls.Primitives")
#from System.Windows.Controls.Primitives import Thumb
from System.IO import FileInfo
from System.Windows.Forms import MessageBox, SaveFileDialog, DialogResult
from System.Collections.Generic import List
from Autodesk.Revit.DB import DetailNurbSpline, CurveElement, ElementTransformUtils, \
							  DetailLine, View, ViewDuplicateOption, XYZ, LocationPoint, \
							  TransactionGroup, Transaction, FilteredElementCollector, \
							  ElementId, BuiltInCategory, FamilyInstance, ViewDuplicateOption, \
							  ViewSheet, FamilySymbol, Viewport, DetailEllipse, DetailArc, TextNote, \
							  ScheduleSheetInstance,Element,FilteredElementCollector,ViewSheetSet
from Autodesk.Revit.Creation import ItemFactoryBase
from Autodesk.Revit.UI.Selection import PickBoxStyle
from Autodesk.Revit.UI import RevitCommandId, PostableCommand


import re
import os.path as op
import codecs
from collections import namedtuple

from pyrevit import HOST_APP
from pyrevit import USER_DESKTOP
from pyrevit import framework
from pyrevit.framework import Windows, Drawing, Forms
from pyrevit import coreutils
from pyrevit import forms
from pyrevit import revit, DB
from pyrevit import script
from pyrevit.forms import pick_folder
# -------------------------------
clr.AddReferenceToFileAndPath(r"W:\Dlls\CustomPrintForm")
from CustomPrintForm import PrintForm
#--------------------------------------

__title__ = 'Печатить Листы'
logger = script.get_logger()
AvailableDoc = namedtuple('AvailableDoc', ['name', 'hash', 'linked'])
TitleBlockPrintSettings = \
	namedtuple('TitleBlockPrintSettings', ['psettings', 'set_by_param'])
# Non Printable Char
NPC = u'\u200e'
INDEX_FORMAT = '{{:0{digits}}}'

class ViewSheetListItem():
	#def __init__(self, view_sheet,rev_settings=None,state=False): print_settings=None,
	def __init__(self, view_sheet,view_tblock,album,state=False):
		if view_sheet:
			self._sheet = view_sheet
			self._tblock = view_tblock
			self.name = self._sheet.Name
			self.number = self._sheet.SheetNumber
			self.state = state
			self.Visib = 'Visible'
			self.foreGround = "#FF3CA026"
			self.sheet_name = "{} - {}".format(self.number,self.name)
			if view_tblock:
				speechFormat = view_tblock.Symbol.GetParameters("Speech_Формат")
				if speechFormat:
					self.speech_format = speechFormat[0].AsString()
				else:
					self.speech_format=''
			self.speech_album = view_sheet.LookupParameter('Speech_Альбом').AsString()

			self.issue_date = \
				self._sheet.Parameter[
					DB.BuiltInParameter.SHEET_ISSUE_DATE].AsString()
			self.printable = self._sheet.CanBePrinted

			self._print_index = 0
			self._print_filename = "{} - {}".format(self.number,self.name)
		else:
			self.name = ''
			self.number = ''
			self.state = False
			self.Visib = 'hidden'
			self.sheet_name = album
			self.speech_format=''
			self.foreGround = "#FF1C5507"
		#self._print_settings = print_settings
		#self.all_print_settings = print_settings
	@property
	def revit_sheet(self):
		return self._sheet

	@property
	def print_filename(self):
		return self._print_filename

class SheetOption(object):
	def __init__(self, obj,list_name,list_familyName,
					familyInstance_Id,familySymbol_Id,speech_format,state=False):
		self.name = "{} - {}".format(obj.SheetNumber,obj.Name)
		self.familyName = "{} - {}".format(list_name,list_familyName)
		self.sheet_name = obj.Name
		self.id = obj.Id
		self.familyInstance_Id = familyInstance_Id
		self.familySymbol_Id = familySymbol_Id
		self.speech_format = speech_format
		self.obj = obj
		self.revit_sheet = obj
		self.state = state
		self.printable = obj.CanBePrinted
		# def __nonzero__(self):
			# return self.state
		# def __str__(self):
			# return self.name
class SymbolOption(object):
	def __init__(self, obj):
		self.familyName = '{} '.format(obj.FamilyName)
		self.Name = '{} '.format(Element.Name.GetValue(obj))
		self.id = obj.Id
		self.obj = obj
		
class SymbolStyle(object):
	def __init__(self, obj, symbolName,symbolColor, iisEnabled):
		self.id = obj.id
		self.iisEnabled = iisEnabled
		self.familyName = obj.familyName
		self.Name = symbolName
		self.color = symbolColor
		self.obj = obj
def GroupByParameter(lst, func):
	res = {}
	for el in lst:
		key = func(el)
		if key in res:
			res[key].append(el)
		else:
			res[key] = [el]
	return res			
class PrintSettingListItem(object):
	def __init__(self, print_settings=None):
		self._psettings = print_settings

	@property
	def name(self):
		if isinstance(self._psettings, DB.InSessionPrintSetting):
			return "<In Session>"
		else:
			return self._psettings.Name

	@property
	def print_settings(self):
		return self._psettings

	@property
	def print_params(self):
		if self.print_settings:
			return self.print_settings.PrintParameters

	@property
	def paper_size(self):
		try:
			if self.print_params:
				return self.print_params.PaperSize
		except Exception:
			pass

	@property
	def allows_variable_paper(self):
		return False


class VariablePaperPrintSettingListItem(PrintSettingListItem):
	def __init__(self):
		PrintSettingListItem.__init__(self, None)

	@property
	def name(self):
		return "<Variable Paper Size>"

	@property
	def allows_variable_paper(self):
		return True
		
class PrintSheetsWindow(forms.WPFWindow):
	def __init__(self, xaml_file_name,**kwargs):
		forms.WPFWindow.__init__(self, xaml_file_name)
		#self.doc = __revit__.ActiveUIDocument.Document

		self._init_psettings = None
		self._scheduled_sheets = []
		#self.sheet_list = kwargs.get('list', None)
		#self.list_Printers.ItemsSource = kwargs.get('symbols', None)
		self.sheetlist_set()
		self._setup_printers()
		self._setup_print_settings()
		self._set_Lists()
		# self._setup_docs_list()
		#print(self.selected_doc)
		self.xx =True
		print_mgr = self._get_printmanager()
		#print(print_mgr.ViewSheetSetting.Revert())
	# doc and schedule
	@property
	def selected_doc(self):
		selected_doc = __revit__.ActiveUIDocument.Document
		for open_doc in revit.docs:
			if open_doc.GetHashCode() == selected_doc.GetHashCode():
				#print("Yes")
				return open_doc
	@property
	def sheet_list(self):
		return self.sheets_lb.ItemsSource
	@property
	def revit_sheet(self):
		return self._sheet

	@sheet_list.setter
	def sheet_list(self, value):
		self.sheets_lb.ItemsSource = value
	@property
	def combine_print(self):
		return self.combine_cb.IsChecked
	@property
	def selected_sheets(self):
		return self.sheets_lb.SelectedItems
	@property
	def selected_printer(self):
		return self.printers_cb.SelectedItem
	@property
	def selected_print_setting(self):
		return self.printsettings_cb.SelectedItem
	def _verify_context(self):
		new_context = []
		for item in self.sheet_list:
			if not hasattr(item, 'state'):
				new_context.append(BaseCheckBoxItem(item))
			else:
				new_context.append(item)

		self.sheet_list = new_context
	# def _setup_docs_list(self):
		# if not revit.doc.IsFamilyDocument:
			# docs = [AvailableDoc(name=revit.doc.Title,
								 # hash=revit.doc.GetHashCode(),
								 # linked=False)]
			# docs.extend([
				# AvailableDoc(name=x.Title, hash=x.GetHashCode(), linked=True)
				# for x in revit.query.get_all_linkeddocs(doc=revit.doc)
			# ])
			# self.documents_cb.ItemsSource = docs
			# self.documents_cb.SelectedIndex = 0
	def sheet_selection_changed(self, sender, args):
		#print('List has Changed {}'.format(self.xx))
		self.xx = True
		
	def _set_states(self, state=True,selected=False):
		all_items = self.sheet_list
		if selected:
			current_list = self.selected_sheets
		else:
			current_list = self.sheet_list
		for it in current_list:
			it.state = state

		self.sheet_list = None
		self.sheet_list = all_items

	def check_selected(self, sender, args):
		"""Mark selected checkboxes as checked."""
		#print('Selected {}\n'.format(self.xx))
		if self.xx: 
			self._set_states(state=True, selected=True)
			self.xx = False

	def uncheck_selected(self, sender, args):
		"""Mark selected checkboxes as unchecked."""
		if self.xx==True:
			self._set_states(state=False, selected=True)
			self.xx = False
	def edit_formats(self, sender, args):
		editfmt_wnd = \
			EditNamingFormatsWindow(
				'EditNamingFormats.xaml',
				start_with=self.selected_naming_format
				)
		editfmt_wnd.show_dialog()
		self.namingformat_cb.ItemsSource = editfmt_wnd.naming_formats
		self.namingformat_cb.SelectedItem = editfmt_wnd.selected_naming_format
# ---------------------------------------------------------------------------------  Setup PrintSetting
	def _get_printmanager(self):
		try:
			return self.selected_doc.PrintManager
		except Exception as printerr:
			logger.critical('Error getting printer manager from document. '
							'Most probably there is not a printer defined '
							'on your system. | %s', printerr)
			return None
			
	def _setup_printers(self):
		printers = list(Drawing.Printing.PrinterSettings.InstalledPrinters)
		self.printers_cb.ItemsSource = printers
		print_mgr = self._get_printmanager()
		self.printers_cb.SelectedItem = print_mgr.PrinterName

	def get_print_settings(self):
		print_settings = [VariablePaperPrintSettingListItem()]
		print_settings.extend(
			[PrintSettingListItem(self.selected_doc.GetElement(x))
			 for x in self.selected_doc.GetPrintSettingIds()]
			)
		print_mgr = self._get_printmanager()
		if isinstance(print_mgr.PrintSetup.CurrentPrintSetting,
					  DB.InSessionPrintSetting):
			in_session = PrintSettingListItem(
				print_mgr.PrintSetup.CurrentPrintSetting
				)
			print_settings.append(in_session)

		return print_settings
	def _setup_print_settings(self):
		print_settings = [VariablePaperPrintSettingListItem()]
		print_settings.extend(
			[PrintSettingListItem(self.selected_doc.GetElement(x))
			 for x in self.selected_doc.GetPrintSettingIds()]
			)
		print_mgr = self._get_printmanager()
		if isinstance(print_mgr.PrintSetup.CurrentPrintSetting,
					  DB.InSessionPrintSetting):
			in_session = PrintSettingListItem(
				print_mgr.PrintSetup.CurrentPrintSetting
				)
			print_settings.append(in_session)
			self.printsettings_cb.SelectedItem = in_session
		else:
			self._init_psettings = print_mgr.PrintSetup.CurrentPrintSetting
			cur_psetting_name = print_mgr.PrintSetup.CurrentPrintSetting.Name
			for psetting in print_settings:
				if psetting.name == cur_psetting_name:
					self.printsettings_cb.SelectedItem = psetting
		# for x in print_settings:
			# print '{} ---- {}'.format(x.name,x.print_params)
		self.printsettings_cb.ItemsSource = print_settings	
		return print_settings
# -------------------------------------------------------------------------------------- Set Sheets  
	def _get_ordered_schedule_sheets(self):
		sheets = DB.FilteredElementCollector(self.selected_doc)\
				.OfClass(ViewSheet)\
				.WhereElementIsNotElementType()\
				.ToElements()
		return sheets
	def _find_sheet_tblock(self, revit_sheet, tblocks):
		for tblock in tblocks:
			view_sheet = revit_sheet.Document.GetElement(tblock.OwnerViewId)
			if view_sheet.Id == revit_sheet.Id:
				return tblock
		return sheets
	
	def _lists_albums(self,set_lists): 
		albums = []
		n = len(set_lists)
		for i in range(n): 
			j = 0
			NotRepeated = True
			while(j < i): 
				if (set_lists[j] == set_lists[i]):
					NotRepeated = False
					break
				j += 1
			if (NotRepeated): 
				albums.append(set_lists[i])
		return albums
	def sort_fun(self,str):
		list = [int(x) for x in re.findall(r'\b\d+\b', str)]
		return list[0]	
	def sheetlist_set(self):
		tblocks = FilteredElementCollector(self.selected_doc) \
		.OfClass(FamilyInstance) \
		.OfCategory(BuiltInCategory.OST_TitleBlocks)\
		.ToElements()
		#sheet_printsettings = self._get_sheet_printsettings(tblocks,self.printsettings_cb.ItemsSource)
		self._scheduled_sheets = [
			ViewSheetListItem(
				view_sheet=x,
				view_tblock=self._find_sheet_tblock(x, tblocks),
				album='',
				state=False)
			for x in self._get_ordered_schedule_sheets()
			]
		sorted_sheets = []
		albums = [x.speech_album for x in self._scheduled_sheets]
		speech_albums = self._lists_albums(albums)
		grouped_sheets = GroupByParameter(self._scheduled_sheets, func = lambda x: x.speech_album)
		for album in speech_albums:
			#print self._get_ordered_schedule_sheets()[0].Name
			sorted_sheets.append(ViewSheetListItem('','',album,False))
			ll = sorted(grouped_sheets[album], key= lambda x:self.sort_fun(x.number))
			for z in ll:
				sorted_sheets.append(z)
		
		self.sheet_list = sorted_sheets
#---------------------------------------------------------------------------------------------- Print Functions
	def print_sheets(self, sender, args):
		if self.sheet_list:
			target_sheets =[x for x in self.sheet_list if x.state]
			# for c in target_sheets:
			# 	print c.name
			# if not self.combine_print:				
			# 	# confirm print if a lot of sheets are going to be printed
			# 	printable_count = len([x for x in target_sheets if x.printable])
			#     if printable_count > 5:
			#         # prepare warning message
			#         sheet_count = len(target_sheets)
			#         message = str(printable_count)
			#         if printable_count != sheet_count:
			#             message += ' (out of {} total)'.format(sheet_count)

			#         if not forms.alert('Are you sure you want to print {} '
			#                            'sheets individually? The process can '
			#                            'not be cancelled.'.format(message),
			#                            ok=False, yes=True, no=True):
			#             return
			# close window and submit print
			#self.Close()
			# 			[PrintSettingListItem(self.selected_doc.GetElement(x))
			#  for x in self.selected_doc.GetPrintSettingIds()]
			if self.combine_print:
				self._print_combined_sheets_in_order(target_sheets)
			else:
				self._print_sheets_in_order(target_sheets)
			#self._reset_psettings()
	def get_seperator(self,st):
		seperator_0 = ''
		seperator_1 = ''
		# sperator0 in English
		if 'K' in st:
			seperator_1 = 'K'
		if 'A' in st:
			seperator_1 = 'A'
		if 'x' in st:
			seperator_0 = 'x'
		# sperator0 in Russian
		if 'К' in st:
			seperator_1 = 'К'
		if 'А' in st:
			seperator_1 = 'А'
		if 'х' in st:
			seperator_0 = 'х'
		
		return [seperator_0,seperator_1]
	def get_seperator(self,st):
		seperator_0 = ''
		seperator_1 = ''
		# sperator0 in English
		if 'K' in st:
			seperator_1 = 'K'
		if 'A' in st:
			seperator_1 = 'A'
		if 'x' in st:
			seperator_0 = 'x'
		# sperator0 in Russian
		if 'К' in st:
			seperator_1 = 'К'
		if 'А' in st:
			seperator_1 = 'А'
		if 'х' in st:
			seperator_0 = 'х'
		
		return [seperator_0,seperator_1]

	def add_newForm(self,name_form,height_form,width_form):
		PrintForm.AddCustomPaperSize(name_form,height_form,width_form)

	def _print_sheets_in_order(self, target_sheets):
		# get already printsettings that we have
		printsettings = list(self.get_print_settings())
		printsettings_names = [x.name for x in printsettings]
		# make sure we can access the print config
		print_mgr = self._get_printmanager()
		if not print_mgr:
			return
		print_mgr.PrintToFile = True
		#per_sheet_psettings = self.selected_print_setting.allows_variable_paper
		with revit.TransactionGroup('Set Printer Settings',
								  doc=self.selected_doc):
			# Collect existing sheet sets
			print_sets = self._setup_print_settings()
			print_mgr.SelectNewPrintDriver(self.selected_printer)
			print_mgr.PrintRange = DB.PrintRange.Current
			for sheet in target_sheets:
				right_format = True
				format_hasfound = False
				Print_setup = sheet.speech_format
				if sheet.printable:
					#try:
					#print sheet.speech_format
					with revit.Transaction('Add Printer setup',doc=self.selected_doc):
						# 	sets = [self.selected_doc.GetElement(x) for x in self.selected_doc.GetPrintSettingIds()]
						# 	for x in sets:
						# 		if x.Name == Print_setup:
						# 			self.selected_doc.Delete(x.Id)
						#with revit.Transaction('Set Printer setup',doc=self.selected_doc):	
						Print_setup_hasfound = False
						#sheetFormat = sheet.speech_format
						if Print_setup in printsettings_names:
							ind = printsettings_names.index(Print_setup)
							#print '{} -{}'.format(ind,printsettings[ind-1])
							print_mgr.PrintSetup.CurrentPrintSetting = printsettings[ind].print_settings
							#print print_mgr.PrintSetup.CurrentPrintSetting.Name
							Print_setup_hasfound = True
							print 'print setup has found'
						if not Print_setup_hasfound:
							settings = print_mgr.PrintSetup.InSession
							paper_size_hasfound = False
							# Set PaperSize
							# check if paper size already have
							for size in print_mgr.PaperSizes:
								if size.Name ==  sheet.speech_format:
									settings.PrintParameters.PaperSize = size
									paper_size_hasfound = True
									print 'paper_size has found'
							# if not, we add it
							sep = self.get_seperator(sheet.speech_format)
							[height_form,width_form,check] = check_format(sheet.speech_format,sep)
							if not paper_size_hasfound:
								if sep[0]=='' or sep[1]=='':
									#print sheet.name
									RightFormWindow.show([],'Неправильный Speech_Формат',sheet=sheet)
									right_format = False
									
								else:
									st = sheet.speech_format
									#print '56'
									# speech_format like 240x260K 
									s1 = st.split(sep[1])
									s0 = s1[0].split(sep[0])
									# Add the new Form
									width_form = float(s0[0])
									height_form = float(s0[1])
									if isinstance(width_form,float) and isinstance(height_form,float):
										#print '57'
										self.add_newForm(sheet.speech_format,height_form,width_form)
										print 'paper_size has added'
									else:
										RightFormWindow.show([],'Uncorrect Speech format')
										right_format = False
								# Set PaperSize
								# check if paper size already have
								for size in print_mgr.PaperSizes:
									if size.Name ==  sheet.speech_format:
										settings.PrintParameters.PaperSize = size
							# choose paper orientation Landscape or Portrait Landscape
							settings.PrintParameters.PageOrientation = print_mgr.PrintSetup.CurrentPrintSetting\
																	.PrintParameters.PageOrientation.Landscape
							if sep[1]=='K' or sep[1]=='К': 
								settings.PrintParameters.PageOrientation = print_mgr.PrintSetup.CurrentPrintSetting\
																			.PrintParameters.PageOrientation.Portrait
							# Choose ZoomType Zoom or FitToPage
							# settings.PrintParameters.ZoomType = print_mgr.PrintSetup.CurrentPrintSetting\
							# 										.PrintParameters.ZoomType.FitToPage
							settings.PrintParameters.ZoomType = print_mgr.PrintSetup.CurrentPrintSetting\
																		.PrintParameters.ZoomType.Zoom
							settings.PrintParameters.Zoom = 100
							settings.PrintParameters.PaperPlacement = print_mgr.PrintSetup.CurrentPrintSetting\
																				.PrintParameters.PaperPlacement.Center

							print_mgr.PrintSetup.CurrentPrintSetting = settings
					print_fileName = sheet.sheet_name+'.pdf'
					print_mgr.PrintToFile = True
					print_mgr.PrintToFileName = op.join(r'C:\\',print_fileName)
					with revit.Transaction('Save Printer setup',
						doc=self.selected_doc):
						#print_mgr.PrintSetup.CurrentPrintSetting = sheet.print_settings
						if not Print_setup_hasfound:
							print_mgr.PrintSetup.SaveAs(Print_setup)
							print 'print setup has added'
						if right_format:
							print_mgr.Apply()
							print_mgr.SubmitPrint(sheet.revit_sheet)
					
					# except:
					# 	MessageBox.Show('{}'.format(sys.exc_info()[1]),"Ошибка!")
					# 	#MessageBox.Show('','Error')

				else:
					logger.debug('Sheet %s is not printable. Skipping print.',
								 sheet.number)

	def _print_combined_sheets_in_order(self, target_sheets):

		# get already printsettings that we have
		printsettings = list(self.get_print_settings())
		printsettings_names = [x.name for x in printsettings]
		# make sure we can access the print config
		print_mgr = self._get_printmanager()
		#print("Combine")
		with revit.TransactionGroup('Print Sheets in Order',
									doc=self.selected_doc):
			if not print_mgr:
				return ##print_mgr.PrintSetup.InSession
			with revit.Transaction('Set Printer Settings',
								   doc=self.selected_doc):
				print_mgr.PrintSetup.CurrentPrintSetting = \
					self.selected_print_setting.print_settings
				print_mgr.SelectNewPrintDriver(self.selected_printer)
				print_mgr.PrintRange = DB.PrintRange.Select
			# add non-printable char in front of sheet Numbers
			# to push revit to sort them per user
			sheet_set = DB.ViewSet()
			original_sheetnums = []
			with revit.Transaction('Fix Sheet Numbers',
								   doc=self.selected_doc):
				for idx, sheet in enumerate(target_sheets):
					# check speech_format
					format_hasfound = False
					sheetFormat = sheet.speech_format
					if sheetFormat in printsettings_names:
						ind = printsettings_names.index(sheetFormat)
						#print '{} -{}'.format(ind,printsettings[ind-1])
						print_mgr.PrintSetup.CurrentPrintSetting = printsettings[ind-1].print_settings
						format_hasfound = True
					if not format_hasfound:
						#print '55'
						settings = print_mgr.PrintSetup.InSession
						sep = self.get_seperator(sheet.speech_format)
						if sep[0]=='' or sep[1]=='':
							#print sheet.name
							RightFormWindow.show([],'Неправильный Speech_Формат',sheet=sheet)
							#RightFormWindow().ShowDialog()
							#MessageBox.Show("Error00!")
							right_format = False
							
						else:
							st = sheet.speech_format
							#print '56'
							# speech_format like 240x260K 
							s1 = st.split(sep[1])
							s0 = s1[0].split(sep[0])
							# Add the new Form
							width_form = float(s0[0])
							height_form = float(s0[1])
							if isinstance(width_form,float) and isinstance(height_form,float):
								#print '57'
								self.add_newForm(sheet.speech_format,height_form,width_form)
							else:
								RightFormWindow.show([],'Uncorrect Speech format')
								right_format = False
					rvtsheet = sheet.revit_sheet
					original_sheetnums.append(rvtsheet.SheetNumber)
					rvtsheet.SheetNumber = \
						NPC * (idx + 1) + rvtsheet.SheetNumber
					if sheet.printable:
						sheet_set.Insert(rvtsheet)

			# Collect existing sheet sets
			cl = DB.FilteredElementCollector(self.selected_doc)
			viewsheetsets = cl.OfClass(framework.get_type(DB.ViewSheetSet))\
							  .WhereElementIsNotElementType()\
							  .ToElements()
			all_viewsheetsets = {vss.Name: vss for vss in viewsheetsets}

			sheetsetname = 'OrderedPrintSet'

			with revit.Transaction('Remove Previous Print Set',
								   doc=self.selected_doc):
				# Delete existing matching sheet set
				if sheetsetname in all_viewsheetsets:
					print_mgr.ViewSheetSetting.CurrentViewSheetSet = \
						all_viewsheetsets[sheetsetname]
					print_mgr.ViewSheetSetting.Delete()

			with revit.Transaction('Update Ordered Print Set',
								   doc=self.selected_doc):
				try:
					viewsheet_settings = print_mgr.ViewSheetSetting
					viewsheet_settings.CurrentViewSheetSet.Views = \
						sheet_set
					viewsheet_settings.SaveAs(sheetsetname)
				except Exception as viewset_err:
					sheet_report = ''
					for sheet in sheet_set:
						sheet_report += '{} {}\n'.format(
							sheet.SheetNumber if isinstance(sheet,
															DB.ViewSheet)
							else '---',
							type(sheet)
							)
					logger.critical(
						'Error setting sheet set on print mechanism. '
						'These items are included in the viewset '
						'object:\n%s', sheet_report
						)
					raise viewset_err

			# set print job configurations
			#print_mgr.PrintOrderReverse = self.reverse_print
			try:
				print_mgr.CombinedFile = True
			except Exception as e:
				forms.alert(str(e) +
							'\nSet printer correctly in Print settings.')
				script.exit()
			print_mgr.PrintToFile = True
			print_mgr.PrintToFileName = \
				op.join(r'C:\\', 'Ordered Sheet Set.pdf')
			print_mgr.Apply()
			print_mgr.SubmitPrint()

			# now fix the sheet names
			with revit.Transaction('Restore Sheet Numbers',
								   doc=self.selected_doc):
				for sheet, sheetnum in zip(target_sheets,
										   original_sheetnums):
					rvtsheet = sheet.revit_sheet
					rvtsheet.SheetNumber = sheetnum
	# ------------------------------------------------------------------- Work with view sets ----------------
	def save_set(self, sender, args):
		print_mgr = self._get_printmanager()
		sheet_set = DB.ViewSet()
		set_lists = [li for li in self.sheet_list if li.state]
		for li in set_lists:
			rvtsheet = li.revit_sheet
			#print rvtsheet.Name
			sheet_set.Insert(rvtsheet)
		with revit.TransactionGroup('Add New ViewSet',
										doc=self.selected_doc):
			if not print_mgr:
				return ##print_mgr.PrintSetup.InSession
			with revit.Transaction('Get CurrentPrintSetting',
								doc=self.selected_doc):
				print_mgr.PrintSetup.CurrentPrintSetting = \
					self.selected_print_setting.print_settings
				print_mgr.SelectNewPrintDriver(self.selected_printer)
				print_mgr.PrintRange = DB.PrintRange.Select
			with revit.Transaction('Remove ViewSheet Set',
									doc=self.selected_doc):
				# Delete existing matching sheet set
				current_ViewSet = self.set_Lists.SelectedItem
				name = current_ViewSet.Name
				print_mgr.ViewSheetSetting.CurrentViewSheetSet = \
					self.set_Lists.SelectedItem
				print_mgr.ViewSheetSetting.Delete()
				# print_mgr.ViewSheetSetting.CurrentViewSheetSet.Views =sheet_set
				# print print_mgr.ViewSheetSetting.CurrentViewSheetSet.Name
				# print_mgr.ViewSheetSetting.Save()
		self.saveSet_as('','',sheetsetname=name,sheetSet = sheet_set)
			#self._set_Lists(0)
	def saveSet_as(self,sender,args,**kwargs):
		sheetsetname =  kwargs.get('sheetsetname')
		print_mgr = self._get_printmanager()
		sheet_set = kwargs.get('sheetSet')
		#index = kwargs.get('index')
		if not sheet_set:
			sheet_set = DB.ViewSet()
			set_lists = [li for li in self.sheet_list if li.state]
			for li in set_lists:
				rvtsheet = li.revit_sheet
				sheet_set.Insert(rvtsheet)
		print_mgr = self._get_printmanager()
		if not sheetsetname:
			sheetsetname = EnterSetViewName.show([],'Введите Название SetView',button_ok='Ok',button_close='Отмена',field_name="ИМЯ")
		#print sheetsetname
		if 	sheetsetname:
			with revit.TransactionGroup('Add New ViewSet',
										doc=self.selected_doc):
				if not print_mgr:
					return ##print_mgr.PrintSetup.InSession
				with revit.Transaction('Get CurrentPrintSetting',
									doc=self.selected_doc):
					print_mgr.PrintSetup.CurrentPrintSetting = \
						self.selected_print_setting.print_settings
					print_mgr.SelectNewPrintDriver(self.selected_printer)
					print_mgr.PrintRange = DB.PrintRange.Select


				with revit.Transaction('Save the new ViewSet',
									doc=self.selected_doc):
					try:
						viewsheet_settings = print_mgr.ViewSheetSetting
						viewsheet_settings.CurrentViewSheetSet.Views = sheet_set
						viewsheet_settings.SaveAs(sheetsetname)
						
					except Exception as viewset_err:
						logger.critical(
							'Error setting sheet set on print mechanism. '
							'These items are included in the viewset '
							'object:\n')
						raise viewset_err
				viewSheetSets = self.get_viewSheetSets()
				#if not index:
				index = len(viewSheetSets) - 1 
				self._set_Lists(index)

	def rename_set(self, sender, args):
		print_mgr = self._get_printmanager()
		viewSheetSets = self.get_viewSheetSets()
		sets_names = [s.Name for s in viewSheetSets]
		index = sets_names.index(self.set_Lists.SelectedItem.Name)

		sheetsetname = EnterSetViewName.show([],'Введите Название SetView',\
					            button_ok='Ok',button_close='Отмена',field_name="ИМЯ")
		if sheetsetname in sets_names:
			MessageBox.Show("The set already exist","Error")
			#raise SystemExit(1)
		else:
			with revit.TransactionGroup('Add New ViewSet',
											doc=self.selected_doc):
				if not print_mgr:
					return ##print_mgr.PrintSetup.InSession
				with revit.Transaction('Get CurrentPrintSetting',
									doc=self.selected_doc):
					print_mgr.PrintSetup.CurrentPrintSetting = \
						self.selected_print_setting.print_settings
					print_mgr.SelectNewPrintDriver(self.selected_printer)
					print_mgr.PrintRange = DB.PrintRange.Select
				with revit.Transaction('Remove ViewSheet Set',
										doc=self.selected_doc):
					# Delete existing matching sheet set
					current_ViewSet = self.set_Lists.SelectedItem
					name = current_ViewSet.Name
					print_mgr.ViewSheetSetting.CurrentViewSheetSet = \
						self.set_Lists.SelectedItem
					print_mgr.ViewSheetSetting.Rename(sheetsetname)
					self._set_Lists(index)

	def delete_set(self, sender, args):
		print_mgr = self._get_printmanager()
		viewSheetSets = self.get_viewSheetSets()
		sets_names = [s.Name for s in viewSheetSets]
		index = sets_names.index(self.set_Lists.SelectedItem.Name)
		with revit.TransactionGroup('Add New ViewSet',
										doc=self.selected_doc):
			if not print_mgr:
				return ##print_mgr.PrintSetup.InSession
			with revit.Transaction('Get CurrentPrintSetting',
								doc=self.selected_doc):
				print_mgr.PrintSetup.CurrentPrintSetting = \
					self.selected_print_setting.print_settings
				print_mgr.SelectNewPrintDriver(self.selected_printer)
				print_mgr.PrintRange = DB.PrintRange.Select
			with revit.Transaction('Remove ViewSheet Set',
									doc=self.selected_doc):
				# Delete existing matching sheet set
				print_mgr.ViewSheetSetting.CurrentViewSheetSet = \
					self.set_Lists.SelectedItem
				print_mgr.ViewSheetSetting.Delete()
			if index:
				self._set_Lists(index-1)
			else:
				self._set_Lists(index)
#---------------------------------------------------------------------------------- Set View Sets ----------------			
	def get_viewSheetSets(self):
		lists = FilteredElementCollector(doc).OfClass(ViewSheetSet)\
				.WhereElementIsNotElementType()\
				.ToElements()
		return lists
	def _set_Lists(self,index=0):
		viewSheetSets = self.get_viewSheetSets()
		size_sets =  len(viewSheetSets)
		self.set_Lists.SelectedItem = viewSheetSets[index]
		self.set_Lists.ItemsSource = viewSheetSets
		
	def	set_lists_changed(self,sender, args):
		#print 'dfgd'
		all_lists = self.sheet_list
		set_List = self.set_Lists.SelectedItem
		#print '1: {}'.format(set_List.Name)
		set_views = set_List.Views
		for lis in all_lists:
			lis.state = False
		for lis in all_lists:
			for v in set_views:
				if lis.name == v.Name:
					lis.state = True
					#print v.Name
		# for l in all_lists:
		# 	print l.name
		self.sheets_lb.ItemsSource = None
		self.sheets_lb.ItemsSource = all_lists
class EnterSetViewName(forms.TemplateUserInputWindow):
	xaml_source = op.join(op.dirname(__file__),'BaseWindow.xaml')
	
	def _setup(self, **kwargs):		
		button_ok = kwargs.get('button_ok', None)
		if button_ok:
			self.addField.Content = button_ok
		button_close = kwargs.get('button_close', None)
		if button_close:
			self.closeField.Content = button_close
		field_name = kwargs.get('field_name', None)
		if field_name:
			self.setfield.Text = field_name

	def insert_Name(self, sender, args):
		"""Handle select button click."""
		self.response = self.NameField.Text
		self.Close()
	def close_Field(self, sender, args):
		self.Close()
class RightFormWindow(forms.TemplateUserInputWindow):
	xaml_source = op.join(op.dirname(__file__),'FormWindow.xaml')
	
	def _setup(self, **kwargs):		
	 	sheet = kwargs.get('sheet', None)
	 	self.sheetName.Text = sheet.sheet_name
		#self.sheetName = self._context

	# def _list_options(self, checkbox_filter=None):
	# 	self.sheetName = self._context
	def close_Field(self, sender, args):
		self.Close()
# ---------------------------------------------------------	
#if __name__ == '__main__':
doc = __revit__.ActiveUIDocument.Document
sheets = FilteredElementCollector(doc) \
				.OfClass(ViewSheet) \
				.ToElements()
familyInstances = FilteredElementCollector(doc) \
				.OfClass(FamilyInstance) \
				.OfCategory(BuiltInCategory.OST_TitleBlocks)\
				.ToElements()
familySymbols = FilteredElementCollector(doc) \
				.OfClass(FamilySymbol) \
				.OfCategory(BuiltInCategory.OST_TitleBlocks)\
				.ToElements()

			
list_sheets=[]
#sheets_familyName=[]
list_EnSymbols=[]

# The colors of the states /Enable - Disenable/ for the 
c_En = "#FFA2D88D"
c_DisEn = "#FF1C5507"

list_Symbols= [SymbolOption(x) for x in familySymbols]

list_EnSymbols.append(SymbolStyle(list_Symbols[0],list_Symbols[0].familyName,c_DisEn,False))
#print(list_familySymbols[0].symbolName)
new_familyName = list_Symbols[0].familyName
unsorted_list = []
for el in list_Symbols:
	if el.familyName == new_familyName: 
		unsorted_list.append(el)
	else:
		sorted_list = sorted(unsorted_list, key= lambda SymbolOption:SymbolOption.Name)
		for sy in sorted_list:
			list_EnSymbols.append(SymbolStyle(sy,sy.Name,c_En,True))
		list_EnSymbols.append(SymbolStyle(el,el.familyName,c_DisEn,False))
		# Update SymbolFamily and refill unsortedList el.symbol_Name,c_symEn,True
		unsorted_list = []
		unsorted_list.append(el)
		new_familyName = el.familyName
		
sorted_list = sorted(unsorted_list, key= lambda SymbolOption:SymbolOption.Name)
for sy in sorted_list:
	list_EnSymbols.append(SymbolStyle(sy,sy.Name,c_En,True))
nn=1
for sheet in sheets:
	for familyInstance in familyInstances:
		if familyInstance.OwnerViewId == sheet.Id:
			list_name = familyInstance.Name
			list_familyName = familyInstance.Symbol.FamilyName
			format = familyInstance.Symbol.GetParameters("Speech_Формат")
			if format:
				speech_format = format[0].AsString()
			else:
				speech_format = ''
			list_obj = SheetOption(sheet,list_name,list_familyName,
								  familyInstance.Id,familyInstance.Symbol.Id,speech_format)
			list_sheets.append(list_obj)
			nn+=1
#for x in speech_format:
#	print x.AsString
try:
	window = PrintSheetsWindow('PrintSheets.xaml',list=list_sheets,symbols=list_EnSymbols)
	window.ShowDialog()
except :
	#traceback.print_exc(file=sys.stdout)
	MessageBox.Show('{}'.format(sys.exc_info()[1]),"Ошибка!")
	window.Close()
	#sys.exit(1)




